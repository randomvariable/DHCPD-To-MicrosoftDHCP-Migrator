//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from DHCPDConfig.g4 by ANTLR 4.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.1")]
[System.CLSCompliant(false)]
public partial class DHCPDConfigParser : Parser {
	public const int
		DOT=1, SLASH=2, COLON=3, SEMI=4, LPAREN=5, MY=6, PARTNER=7, AT=8, RPAREN=9, 
		LBRACE=10, RBRACE=11, HOST=12, CLASS=13, SHARED_NETWORK=14, SUBNET=15, 
		SUBNET6=16, GROUP=17, FIXED_ADDRESS=18, LEASE=19, STARTS=20, ENDS=21, 
		TIMESTAMP=22, HARDWARE=23, CLIENT_HOSTNAME=24, DYNAMIC_BOOTP=25, POOL=26, 
		RANGE=27, TEMPORARY=28, LBRACKET=29, RBRACKET=30, NETMASK=31, AllowDenyKeyword=32, 
		FAILOVER=33, FAILOVER_PEER=34, PEER=35, ADDRESS=36, PORT=37, NEVER=38, 
		DEFAULT_LEASE_TIME=39, MAX_LEASE_TIME=40, DYNAMIC_BOOTP_LEASE_CUTOFF=41, 
		DYNAMIC_BOOTP_LEASE_LENGTH=42, DDNS_UPDATE_STYLE=43, BOOT_UNKNOWN_CLIENTS=44, 
		ONE_LEASE_PER_CLIENT=45, USE_HOST_DECL_NAME=46, NEXT_SERVER=47, SERVER_IDENTIFIER=48, 
		FILENAME=49, ALLOW=50, DENY=51, USE_LEASE_ADDR_FOR_DEFAULT_ROUTE=52, AUTHORITATIVE=53, 
		NOT_AUTHORITATIVE=54, PRIMARY=55, SECONDARY=56, OPTION=57, VENDOR_CLASS=58, 
		USER_CLASS=59, STATE=60, TSTP=61, TSFP=62, ATSFP=63, BINDING=64, NEXT=65, 
		CLTT=66, SERVER_DUID=67, HARDWARE_TYPES=68, Boolean=69, QUOTE=70, ColonSeparatedList=71, 
		Date=72, NUMBER=73, Ip4Address=74, BACKSLASH=75, UID=76, UIDSTRING=77, 
		SERVERDUIDSTRING=78, STRING=79, WS=80, COMMENT=81;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'.'", "'/'", "':'", "';'", "'('", "'my'", "'partner'", "'at'", 
		"')'", "'{'", "'}'", "'host'", "'class'", "'shared-network'", "'subnet'", 
		"'subnet6'", "'group'", "'fixed-address'", "'lease'", "'starts'", "'ends'", 
		"'timestamp'", "'hardware'", "'client-hostname'", "'dynamic-bootp'", "'pool'", 
		"'range'", "'temporary'", "'['", "']'", "'netmask'", "AllowDenyKeyword", 
		"'failover'", "'failoverpeer'", "'peer'", "'address'", "'port'", "'never'", 
		"'default-lease-time'", "'max-lease-time'", "'dynamic-bootp-lease-cutoff'", 
		"'dynamic-bootp-lease-length'", "'ddns-update-style'", "'boot-unknown-clients'", 
		"'one-lease-per-client'", "'use-host-decl-name'", "'next-server'", "'server-identifier'", 
		"'filename'", "'allow'", "'deny'", "'use-lease-addr-for-default-route'", 
		"'authoritative'", "'notauthoritative'", "'primary'", "'secondary'", "'option'", 
		"'vendorclass'", "'userclass'", "'state'", "'tstp'", "'tsfp'", "'atsfp'", 
		"'binding'", "'next'", "'cltt'", "'server-duid'", "HARDWARE_TYPES", "Boolean", 
		"'\"'", "ColonSeparatedList", "Date", "NUMBER", "Ip4Address", "'\\'", 
		"'uid'", "UIDSTRING", "SERVERDUIDSTRING", "STRING", "WS", "COMMENT"
	};
	public const int
		RULE_config = 0, RULE_stringParameter = 1, RULE_parameter = 2, RULE_declaration = 3, 
		RULE_statement = 4, RULE_statements = 5, RULE_hostname = 6, RULE_hostDeclaration = 7, 
		RULE_klass = 8, RULE_classDeclaration = 9, RULE_sharedNetwork = 10, RULE_sharedNetworkDeclaration = 11, 
		RULE_subnet = 12, RULE_netmask = 13, RULE_subnetDeclaration = 14, RULE_subnet6 = 15, 
		RULE_subnet6Declaration = 16, RULE_groupDeclaration = 17, RULE_fixedAddress = 18, 
		RULE_fixedAddressParameter = 19, RULE_ipAddrOrHostnames = 20, RULE_lease = 21, 
		RULE_leaseAddress = 22, RULE_leaseDeclaration = 23, RULE_leaseParameters = 24, 
		RULE_ip6net = 25, RULE_ip4Address = 26, RULE_hostnameOrIpAddress = 27, 
		RULE_timestamp = 28, RULE_startEnd = 29, RULE_leaseParameter = 30, RULE_poolDeclaration = 31, 
		RULE_rangeLow = 32, RULE_rangeHigh = 33, RULE_addressRangeDeclaration = 34, 
		RULE_rangeLow6 = 35, RULE_rangeHigh6 = 36, RULE_addressRange6Declaration = 37, 
		RULE_ip6Address = 38, RULE_fixedPrefix6 = 39, RULE_failoverDeclaration = 40, 
		RULE_failoverStateDeclaration = 41, RULE_state = 42, RULE_date = 43, RULE_failoverStateStatement = 44, 
		RULE_peerStatement = 45, RULE_leaseTime = 46, RULE_ipAddressWithSubnet = 47, 
		RULE_ip6Prefix = 48, RULE_hardwareParameter = 49, RULE_optionParam = 50, 
		RULE_optionStatement = 51, RULE_optionOptionStatement = 52;
	public static readonly string[] ruleNames = {
		"config", "stringParameter", "parameter", "declaration", "statement", 
		"statements", "hostname", "hostDeclaration", "klass", "classDeclaration", 
		"sharedNetwork", "sharedNetworkDeclaration", "subnet", "netmask", "subnetDeclaration", 
		"subnet6", "subnet6Declaration", "groupDeclaration", "fixedAddress", "fixedAddressParameter", 
		"ipAddrOrHostnames", "lease", "leaseAddress", "leaseDeclaration", "leaseParameters", 
		"ip6net", "ip4Address", "hostnameOrIpAddress", "timestamp", "startEnd", 
		"leaseParameter", "poolDeclaration", "rangeLow", "rangeHigh", "addressRangeDeclaration", 
		"rangeLow6", "rangeHigh6", "addressRange6Declaration", "ip6Address", "fixedPrefix6", 
		"failoverDeclaration", "failoverStateDeclaration", "state", "date", "failoverStateStatement", 
		"peerStatement", "leaseTime", "ipAddressWithSubnet", "ip6Prefix", "hardwareParameter", 
		"optionParam", "optionStatement", "optionOptionStatement"
	};

	public override string GrammarFileName { get { return "DHCPDConfig.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public DHCPDConfigParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ConfigContext : ParserRuleContext {
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ConfigContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_config; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterConfig(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitConfig(this);
		}
	}

	[RuleVersion(0)]
	public ConfigContext config() {
		ConfigContext _localctx = new ConfigContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_config);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << SEMI) | (1L << HOST) | (1L << CLASS) | (1L << SHARED_NETWORK) | (1L << SUBNET) | (1L << GROUP) | (1L << FIXED_ADDRESS) | (1L << LEASE) | (1L << STARTS) | (1L << ENDS) | (1L << HARDWARE) | (1L << CLIENT_HOSTNAME) | (1L << DYNAMIC_BOOTP) | (1L << POOL) | (1L << RANGE) | (1L << FAILOVER) | (1L << PEER) | (1L << ADDRESS) | (1L << PORT) | (1L << DEFAULT_LEASE_TIME) | (1L << MAX_LEASE_TIME) | (1L << DYNAMIC_BOOTP_LEASE_CUTOFF) | (1L << DYNAMIC_BOOTP_LEASE_LENGTH) | (1L << DDNS_UPDATE_STYLE) | (1L << BOOT_UNKNOWN_CLIENTS) | (1L << ONE_LEASE_PER_CLIENT) | (1L << USE_HOST_DECL_NAME) | (1L << NEXT_SERVER) | (1L << SERVER_IDENTIFIER) | (1L << FILENAME) | (1L << ALLOW) | (1L << DENY) | (1L << USE_LEASE_ADDR_FOR_DEFAULT_ROUTE) | (1L << AUTHORITATIVE) | (1L << NOT_AUTHORITATIVE) | (1L << PRIMARY) | (1L << SECONDARY) | (1L << OPTION) | (1L << VENDOR_CLASS) | (1L << USER_CLASS) | (1L << TSTP) | (1L << TSFP) | (1L << ATSFP))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (BINDING - 64)) | (1L << (NEXT - 64)) | (1L << (CLTT - 64)) | (1L << (Boolean - 64)) | (1L << (QUOTE - 64)) | (1L << (ColonSeparatedList - 64)) | (1L << (NUMBER - 64)) | (1L << (Ip4Address - 64)) | (1L << (UIDSTRING - 64)) | (1L << (SERVERDUIDSTRING - 64)) | (1L << (STRING - 64)))) != 0)) {
				{
				{
				State = 106; statement();
				}
				}
				State = 111;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringParameterContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public StringParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_stringParameter; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterStringParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitStringParameter(this);
		}
	}

	[RuleVersion(0)]
	public StringParameterContext stringParameter() {
		StringParameterContext _localctx = new StringParameterContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_stringParameter);
		try {
			State = 116;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 112; Match(QUOTE);
				State = 113; Match(STRING);
				State = 114; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 115; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public LeaseTimeContext leaseTime() {
			return GetRuleContext<LeaseTimeContext>(0);
		}
		public ITerminalNode USE_LEASE_ADDR_FOR_DEFAULT_ROUTE() { return GetToken(DHCPDConfigParser.USE_LEASE_ADDR_FOR_DEFAULT_ROUTE, 0); }
		public FixedAddressParameterContext fixedAddressParameter() {
			return GetRuleContext<FixedAddressParameterContext>(0);
		}
		public ITerminalNode DDNS_UPDATE_STYLE() { return GetToken(DHCPDConfigParser.DDNS_UPDATE_STYLE, 0); }
		public LeaseParameterContext leaseParameter() {
			return GetRuleContext<LeaseParameterContext>(0);
		}
		public OptionStatementContext optionStatement() {
			return GetRuleContext<OptionStatementContext>(0);
		}
		public ITerminalNode FILENAME() { return GetToken(DHCPDConfigParser.FILENAME, 0); }
		public ITerminalNode BOOT_UNKNOWN_CLIENTS() { return GetToken(DHCPDConfigParser.BOOT_UNKNOWN_CLIENTS, 0); }
		public ITerminalNode DYNAMIC_BOOTP_LEASE_CUTOFF() { return GetToken(DHCPDConfigParser.DYNAMIC_BOOTP_LEASE_CUTOFF, 0); }
		public ITerminalNode OPTION() { return GetToken(DHCPDConfigParser.OPTION, 0); }
		public ITerminalNode AllowDenyKeyword() { return GetToken(DHCPDConfigParser.AllowDenyKeyword, 0); }
		public ITerminalNode NOT_AUTHORITATIVE() { return GetToken(DHCPDConfigParser.NOT_AUTHORITATIVE, 0); }
		public ITerminalNode SERVERDUIDSTRING() { return GetToken(DHCPDConfigParser.SERVERDUIDSTRING, 0); }
		public ITerminalNode DEFAULT_LEASE_TIME() { return GetToken(DHCPDConfigParser.DEFAULT_LEASE_TIME, 0); }
		public ITerminalNode DYNAMIC_BOOTP_LEASE_LENGTH() { return GetToken(DHCPDConfigParser.DYNAMIC_BOOTP_LEASE_LENGTH, 0); }
		public ITerminalNode ALLOW() { return GetToken(DHCPDConfigParser.ALLOW, 0); }
		public ITerminalNode ONE_LEASE_PER_CLIENT() { return GetToken(DHCPDConfigParser.ONE_LEASE_PER_CLIENT, 0); }
		public ITerminalNode USE_HOST_DECL_NAME() { return GetToken(DHCPDConfigParser.USE_HOST_DECL_NAME, 0); }
		public PeerStatementContext peerStatement() {
			return GetRuleContext<PeerStatementContext>(0);
		}
		public ITerminalNode SECONDARY() { return GetToken(DHCPDConfigParser.SECONDARY, 0); }
		public ITerminalNode NEXT_SERVER() { return GetToken(DHCPDConfigParser.NEXT_SERVER, 0); }
		public ITerminalNode Date() { return GetToken(DHCPDConfigParser.Date, 0); }
		public ITerminalNode SERVER_IDENTIFIER() { return GetToken(DHCPDConfigParser.SERVER_IDENTIFIER, 0); }
		public ITerminalNode SEMI() { return GetToken(DHCPDConfigParser.SEMI, 0); }
		public ITerminalNode PRIMARY() { return GetToken(DHCPDConfigParser.PRIMARY, 0); }
		public HardwareParameterContext hardwareParameter() {
			return GetRuleContext<HardwareParameterContext>(0);
		}
		public ITerminalNode AUTHORITATIVE() { return GetToken(DHCPDConfigParser.AUTHORITATIVE, 0); }
		public StringParameterContext stringParameter() {
			return GetRuleContext<StringParameterContext>(0);
		}
		public ITerminalNode MAX_LEASE_TIME() { return GetToken(DHCPDConfigParser.MAX_LEASE_TIME, 0); }
		public ITerminalNode Boolean() { return GetToken(DHCPDConfigParser.Boolean, 0); }
		public ITerminalNode DENY() { return GetToken(DHCPDConfigParser.DENY, 0); }
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_parameter; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_parameter);
		try {
			State = 195;
			switch ( Interpreter.AdaptivePredict(_input,2,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 118; Match(DEFAULT_LEASE_TIME);
				State = 119; leaseTime();
				State = 120; Match(SEMI);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 122; Match(MAX_LEASE_TIME);
				State = 123; leaseTime();
				State = 124; Match(SEMI);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 126; Match(DYNAMIC_BOOTP_LEASE_CUTOFF);
				State = 127; Match(Date);
				State = 128; Match(SEMI);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 129; Match(DYNAMIC_BOOTP_LEASE_LENGTH);
				State = 130; leaseTime();
				State = 131; Match(SEMI);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 133; Match(DDNS_UPDATE_STYLE);
				State = 134; stringParameter();
				State = 135; Match(SEMI);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 137; Match(BOOT_UNKNOWN_CLIENTS);
				State = 138; Match(Boolean);
				State = 139; Match(SEMI);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 140; Match(ONE_LEASE_PER_CLIENT);
				State = 141; Match(Boolean);
				State = 142; Match(SEMI);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 143; Match(USE_HOST_DECL_NAME);
				State = 144; Match(Boolean);
				State = 145; Match(SEMI);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 146; Match(NEXT_SERVER);
				State = 147; stringParameter();
				State = 148; Match(SEMI);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 150; Match(SERVER_IDENTIFIER);
				State = 151; stringParameter();
				State = 152; Match(SEMI);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 154; Match(FILENAME);
				State = 155; stringParameter();
				State = 156; Match(SEMI);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 158; hardwareParameter();
				State = 159; Match(SEMI);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 161; fixedAddressParameter();
				State = 162; Match(SEMI);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 164; Match(ALLOW);
				State = 165; Match(AllowDenyKeyword);
				State = 166; Match(SEMI);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 167; Match(DENY);
				State = 168; Match(AllowDenyKeyword);
				State = 169; Match(SEMI);
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 170; Match(USE_LEASE_ADDR_FOR_DEFAULT_ROUTE);
				State = 171; Match(Boolean);
				State = 172; Match(SEMI);
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 173; Match(AUTHORITATIVE);
				State = 174; Match(SEMI);
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 175; Match(NOT_AUTHORITATIVE);
				State = 176; Match(SEMI);
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 177; Match(PRIMARY);
				State = 178; Match(SEMI);
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 179; Match(SECONDARY);
				State = 180; Match(SEMI);
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 181; leaseParameter();
				State = 182; Match(SEMI);
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 184; optionStatement();
				State = 185; Match(SEMI);
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 187; peerStatement();
				State = 188; Match(SEMI);
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 190; Match(SERVERDUIDSTRING);
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 191; Match(OPTION);
				State = 192; optionStatement();
				State = 193; Match(SEMI);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		public FailoverStateDeclarationContext failoverStateDeclaration() {
			return GetRuleContext<FailoverStateDeclarationContext>(0);
		}
		public HostDeclarationContext hostDeclaration() {
			return GetRuleContext<HostDeclarationContext>(0);
		}
		public AddressRangeDeclarationContext addressRangeDeclaration() {
			return GetRuleContext<AddressRangeDeclarationContext>(0);
		}
		public SubnetDeclarationContext subnetDeclaration() {
			return GetRuleContext<SubnetDeclarationContext>(0);
		}
		public GroupDeclarationContext groupDeclaration() {
			return GetRuleContext<GroupDeclarationContext>(0);
		}
		public FailoverDeclarationContext failoverDeclaration() {
			return GetRuleContext<FailoverDeclarationContext>(0);
		}
		public ITerminalNode VENDOR_CLASS() { return GetToken(DHCPDConfigParser.VENDOR_CLASS, 0); }
		public SharedNetworkDeclarationContext sharedNetworkDeclaration() {
			return GetRuleContext<SharedNetworkDeclarationContext>(0);
		}
		public LeaseDeclarationContext leaseDeclaration() {
			return GetRuleContext<LeaseDeclarationContext>(0);
		}
		public PoolDeclarationContext poolDeclaration() {
			return GetRuleContext<PoolDeclarationContext>(0);
		}
		public ITerminalNode USER_CLASS() { return GetToken(DHCPDConfigParser.USER_CLASS, 0); }
		public ClassDeclarationContext classDeclaration() {
			return GetRuleContext<ClassDeclarationContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_declaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_declaration);
		try {
			State = 210;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 197; hostDeclaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 198; groupDeclaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 199; sharedNetworkDeclaration();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 200; subnetDeclaration();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 201; Match(VENDOR_CLASS);
				State = 202; classDeclaration();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 203; Match(USER_CLASS);
				State = 204; classDeclaration();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 205; failoverDeclaration();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 206; failoverStateDeclaration();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 207; addressRangeDeclaration();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 208; leaseDeclaration();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 209; poolDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_statement; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 214;
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				{
				State = 212; parameter();
				}
				break;
			case 2:
				{
				State = 213; declaration();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_statements; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitStatements(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		StatementsContext _localctx = new StatementsContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_statements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 219;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << SEMI) | (1L << HOST) | (1L << CLASS) | (1L << SHARED_NETWORK) | (1L << SUBNET) | (1L << GROUP) | (1L << FIXED_ADDRESS) | (1L << LEASE) | (1L << STARTS) | (1L << ENDS) | (1L << HARDWARE) | (1L << CLIENT_HOSTNAME) | (1L << DYNAMIC_BOOTP) | (1L << POOL) | (1L << RANGE) | (1L << FAILOVER) | (1L << PEER) | (1L << ADDRESS) | (1L << PORT) | (1L << DEFAULT_LEASE_TIME) | (1L << MAX_LEASE_TIME) | (1L << DYNAMIC_BOOTP_LEASE_CUTOFF) | (1L << DYNAMIC_BOOTP_LEASE_LENGTH) | (1L << DDNS_UPDATE_STYLE) | (1L << BOOT_UNKNOWN_CLIENTS) | (1L << ONE_LEASE_PER_CLIENT) | (1L << USE_HOST_DECL_NAME) | (1L << NEXT_SERVER) | (1L << SERVER_IDENTIFIER) | (1L << FILENAME) | (1L << ALLOW) | (1L << DENY) | (1L << USE_LEASE_ADDR_FOR_DEFAULT_ROUTE) | (1L << AUTHORITATIVE) | (1L << NOT_AUTHORITATIVE) | (1L << PRIMARY) | (1L << SECONDARY) | (1L << OPTION) | (1L << VENDOR_CLASS) | (1L << USER_CLASS) | (1L << TSTP) | (1L << TSFP) | (1L << ATSFP))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (BINDING - 64)) | (1L << (NEXT - 64)) | (1L << (CLTT - 64)) | (1L << (Boolean - 64)) | (1L << (QUOTE - 64)) | (1L << (ColonSeparatedList - 64)) | (1L << (NUMBER - 64)) | (1L << (Ip4Address - 64)) | (1L << (UIDSTRING - 64)) | (1L << (SERVERDUIDSTRING - 64)) | (1L << (STRING - 64)))) != 0)) {
				{
				{
				State = 216; statement();
				}
				}
				State = 221;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HostnameContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public HostnameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_hostname; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterHostname(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitHostname(this);
		}
	}

	[RuleVersion(0)]
	public HostnameContext hostname() {
		HostnameContext _localctx = new HostnameContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_hostname);
		try {
			State = 227;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 222; Match(QUOTE);
				State = 223; Match(STRING);
				State = 224; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 225; Match(STRING);
				}
				break;
			case NUMBER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 226; Match(NUMBER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HostDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode HOST() { return GetToken(DHCPDConfigParser.HOST, 0); }
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public HostnameContext hostname() {
			return GetRuleContext<HostnameContext>(0);
		}
		public HostDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_hostDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterHostDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitHostDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public HostDeclarationContext hostDeclaration() {
		HostDeclarationContext _localctx = new HostDeclarationContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_hostDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 229; Match(HOST);
			State = 230; hostname();
			State = 231; Match(LBRACE);
			State = 232; statements();
			State = 233; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KlassContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public KlassContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_klass; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterKlass(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitKlass(this);
		}
	}

	[RuleVersion(0)]
	public KlassContext klass() {
		KlassContext _localctx = new KlassContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_klass);
		try {
			State = 239;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 235; Match(QUOTE);
				State = 236; Match(STRING);
				State = 237; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 238; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClassDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public KlassContext klass() {
			return GetRuleContext<KlassContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public ITerminalNode CLASS() { return GetToken(DHCPDConfigParser.CLASS, 0); }
		public ClassDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_classDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterClassDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitClassDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public ClassDeclarationContext classDeclaration() {
		ClassDeclarationContext _localctx = new ClassDeclarationContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_classDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 241; Match(CLASS);
			State = 242; klass();
			State = 243; Match(LBRACE);
			State = 244; statements();
			State = 245; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SharedNetworkContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public SharedNetworkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_sharedNetwork; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterSharedNetwork(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitSharedNetwork(this);
		}
	}

	[RuleVersion(0)]
	public SharedNetworkContext sharedNetwork() {
		SharedNetworkContext _localctx = new SharedNetworkContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_sharedNetwork);
		try {
			State = 251;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 247; Match(QUOTE);
				State = 248; Match(STRING);
				State = 249; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 250; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SharedNetworkDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode SHARED_NETWORK() { return GetToken(DHCPDConfigParser.SHARED_NETWORK, 0); }
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public SharedNetworkContext sharedNetwork() {
			return GetRuleContext<SharedNetworkContext>(0);
		}
		public SharedNetworkDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_sharedNetworkDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterSharedNetworkDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitSharedNetworkDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public SharedNetworkDeclarationContext sharedNetworkDeclaration() {
		SharedNetworkDeclarationContext _localctx = new SharedNetworkDeclarationContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_sharedNetworkDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 253; Match(SHARED_NETWORK);
			State = 254; sharedNetwork();
			State = 255; Match(LBRACE);
			State = 256; statements();
			State = 257; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubnetContext : ParserRuleContext {
		public Ip4AddressContext ip4Address() {
			return GetRuleContext<Ip4AddressContext>(0);
		}
		public SubnetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_subnet; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterSubnet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitSubnet(this);
		}
	}

	[RuleVersion(0)]
	public SubnetContext subnet() {
		SubnetContext _localctx = new SubnetContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_subnet);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 259; ip4Address();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NetmaskContext : ParserRuleContext {
		public Ip4AddressContext ip4Address() {
			return GetRuleContext<Ip4AddressContext>(0);
		}
		public NetmaskContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_netmask; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterNetmask(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitNetmask(this);
		}
	}

	[RuleVersion(0)]
	public NetmaskContext netmask() {
		NetmaskContext _localctx = new NetmaskContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_netmask);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261; ip4Address();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubnetDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode SUBNET() { return GetToken(DHCPDConfigParser.SUBNET, 0); }
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public ITerminalNode NETMASK() { return GetToken(DHCPDConfigParser.NETMASK, 0); }
		public NetmaskContext netmask() {
			return GetRuleContext<NetmaskContext>(0);
		}
		public SubnetContext subnet() {
			return GetRuleContext<SubnetContext>(0);
		}
		public SubnetDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_subnetDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterSubnetDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitSubnetDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public SubnetDeclarationContext subnetDeclaration() {
		SubnetDeclarationContext _localctx = new SubnetDeclarationContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_subnetDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 263; Match(SUBNET);
			State = 264; subnet();
			State = 265; Match(NETMASK);
			State = 266; netmask();
			State = 267; Match(LBRACE);
			State = 268; statements();
			State = 269; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subnet6Context : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public Subnet6Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_subnet6; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterSubnet6(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitSubnet6(this);
		}
	}

	[RuleVersion(0)]
	public Subnet6Context subnet6() {
		Subnet6Context _localctx = new Subnet6Context(_ctx, State);
		EnterRule(_localctx, 30, RULE_subnet6);
		try {
			State = 275;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 271; Match(QUOTE);
				State = 272; Match(STRING);
				State = 273; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 274; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subnet6DeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public ITerminalNode SUBNET6() { return GetToken(DHCPDConfigParser.SUBNET6, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public StringParameterContext stringParameter() {
			return GetRuleContext<StringParameterContext>(0);
		}
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public Subnet6DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_subnet6Declaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterSubnet6Declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitSubnet6Declaration(this);
		}
	}

	[RuleVersion(0)]
	public Subnet6DeclarationContext subnet6Declaration() {
		Subnet6DeclarationContext _localctx = new Subnet6DeclarationContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_subnet6Declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 277; Match(SUBNET6);
			State = 278; stringParameter();
			State = 279; Match(LBRACE);
			State = 280; statements();
			State = 281; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public ITerminalNode GROUP() { return GetToken(DHCPDConfigParser.GROUP, 0); }
		public GroupDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_groupDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterGroupDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitGroupDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public GroupDeclarationContext groupDeclaration() {
		GroupDeclarationContext _localctx = new GroupDeclarationContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_groupDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 283; Match(GROUP);
			State = 284; Match(LBRACE);
			State = 285; statements();
			State = 286; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedAddressContext : ParserRuleContext {
		public Ip4AddressContext ip4Address() {
			return GetRuleContext<Ip4AddressContext>(0);
		}
		public FixedAddressContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_fixedAddress; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterFixedAddress(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitFixedAddress(this);
		}
	}

	[RuleVersion(0)]
	public FixedAddressContext fixedAddress() {
		FixedAddressContext _localctx = new FixedAddressContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_fixedAddress);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 288; ip4Address();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedAddressParameterContext : ParserRuleContext {
		public ITerminalNode FIXED_ADDRESS() { return GetToken(DHCPDConfigParser.FIXED_ADDRESS, 0); }
		public FixedAddressContext fixedAddress() {
			return GetRuleContext<FixedAddressContext>(0);
		}
		public FixedAddressParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_fixedAddressParameter; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterFixedAddressParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitFixedAddressParameter(this);
		}
	}

	[RuleVersion(0)]
	public FixedAddressParameterContext fixedAddressParameter() {
		FixedAddressParameterContext _localctx = new FixedAddressParameterContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_fixedAddressParameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 290; Match(FIXED_ADDRESS);
			State = 291; fixedAddress();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IpAddrOrHostnamesContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public ITerminalNode STRING(int i) {
			return GetToken(DHCPDConfigParser.STRING, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public IReadOnlyList<ITerminalNode> STRING() { return GetTokens(DHCPDConfigParser.STRING); }
		public IpAddrOrHostnamesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_ipAddrOrHostnames; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterIpAddrOrHostnames(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitIpAddrOrHostnames(this);
		}
	}

	[RuleVersion(0)]
	public IpAddrOrHostnamesContext ipAddrOrHostnames() {
		IpAddrOrHostnamesContext _localctx = new IpAddrOrHostnamesContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_ipAddrOrHostnames);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 297;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				State = 297;
				switch (_input.La(1)) {
				case QUOTE:
					{
					State = 293; Match(QUOTE);
					State = 294; Match(STRING);
					State = 295; Match(QUOTE);
					}
					break;
				case STRING:
					{
					State = 296; Match(STRING);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 299;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==QUOTE || _la==STRING );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaseContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public LeaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_lease; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterLease(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitLease(this);
		}
	}

	[RuleVersion(0)]
	public LeaseContext lease() {
		LeaseContext _localctx = new LeaseContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_lease);
		try {
			State = 305;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 301; Match(QUOTE);
				State = 302; Match(STRING);
				State = 303; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 304; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaseAddressContext : ParserRuleContext {
		public Ip4AddressContext ip4Address() {
			return GetRuleContext<Ip4AddressContext>(0);
		}
		public LeaseAddressContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_leaseAddress; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterLeaseAddress(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitLeaseAddress(this);
		}
	}

	[RuleVersion(0)]
	public LeaseAddressContext leaseAddress() {
		LeaseAddressContext _localctx = new LeaseAddressContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_leaseAddress);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 307; ip4Address();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaseDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public LeaseAddressContext leaseAddress() {
			return GetRuleContext<LeaseAddressContext>(0);
		}
		public LeaseParametersContext leaseParameters() {
			return GetRuleContext<LeaseParametersContext>(0);
		}
		public ITerminalNode LEASE() { return GetToken(DHCPDConfigParser.LEASE, 0); }
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public LeaseDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_leaseDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterLeaseDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitLeaseDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public LeaseDeclarationContext leaseDeclaration() {
		LeaseDeclarationContext _localctx = new LeaseDeclarationContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_leaseDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 309; Match(LEASE);
			State = 310; leaseAddress();
			State = 311; Match(LBRACE);
			State = 312; leaseParameters();
			State = 313; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaseParametersContext : ParserRuleContext {
		public LeaseParameterContext leaseParameter(int i) {
			return GetRuleContext<LeaseParameterContext>(i);
		}
		public IReadOnlyList<LeaseParameterContext> leaseParameter() {
			return GetRuleContexts<LeaseParameterContext>();
		}
		public LeaseParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_leaseParameters; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterLeaseParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitLeaseParameters(this);
		}
	}

	[RuleVersion(0)]
	public LeaseParametersContext leaseParameters() {
		LeaseParametersContext _localctx = new LeaseParametersContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_leaseParameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 318;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << CLASS) | (1L << STARTS) | (1L << ENDS) | (1L << HARDWARE) | (1L << CLIENT_HOSTNAME) | (1L << DYNAMIC_BOOTP) | (1L << TSTP) | (1L << TSFP) | (1L << ATSFP))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (BINDING - 64)) | (1L << (NEXT - 64)) | (1L << (CLTT - 64)) | (1L << (UIDSTRING - 64)))) != 0)) {
				{
				{
				State = 315; leaseParameter();
				}
				}
				State = 320;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ip6netContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public Ip6netContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_ip6net; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterIp6net(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitIp6net(this);
		}
	}

	[RuleVersion(0)]
	public Ip6netContext ip6net() {
		Ip6netContext _localctx = new Ip6netContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_ip6net);
		try {
			State = 325;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 321; Match(QUOTE);
				State = 322; Match(STRING);
				State = 323; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 324; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ip4AddressContext : ParserRuleContext {
		public ITerminalNode Ip4Address() { return GetToken(DHCPDConfigParser.Ip4Address, 0); }
		public Ip4AddressContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_ip4Address; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterIp4Address(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitIp4Address(this);
		}
	}

	[RuleVersion(0)]
	public Ip4AddressContext ip4Address() {
		Ip4AddressContext _localctx = new Ip4AddressContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_ip4Address);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 327; Match(Ip4Address);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HostnameOrIpAddressContext : ParserRuleContext {
		public Ip4AddressContext ip4Address() {
			return GetRuleContext<Ip4AddressContext>(0);
		}
		public HostnameContext hostname() {
			return GetRuleContext<HostnameContext>(0);
		}
		public HostnameOrIpAddressContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_hostnameOrIpAddress; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterHostnameOrIpAddress(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitHostnameOrIpAddress(this);
		}
	}

	[RuleVersion(0)]
	public HostnameOrIpAddressContext hostnameOrIpAddress() {
		HostnameOrIpAddressContext _localctx = new HostnameOrIpAddressContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_hostnameOrIpAddress);
		try {
			State = 331;
			switch (_input.La(1)) {
			case QUOTE:
			case NUMBER:
			case STRING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 329; hostname();
				}
				break;
			case Ip4Address:
				EnterOuterAlt(_localctx, 2);
				{
				State = 330; ip4Address();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampContext : ParserRuleContext {
		public ITerminalNode ATSFP() { return GetToken(DHCPDConfigParser.ATSFP, 0); }
		public ITerminalNode Date() { return GetToken(DHCPDConfigParser.Date, 0); }
		public ITerminalNode CLTT() { return GetToken(DHCPDConfigParser.CLTT, 0); }
		public ITerminalNode TSFP() { return GetToken(DHCPDConfigParser.TSFP, 0); }
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public ITerminalNode TSTP() { return GetToken(DHCPDConfigParser.TSTP, 0); }
		public TimestampContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_timestamp; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterTimestamp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitTimestamp(this);
		}
	}

	[RuleVersion(0)]
	public TimestampContext timestamp() {
		TimestampContext _localctx = new TimestampContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_timestamp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 333;
			_la = _input.La(1);
			if ( !(((((_la - 61)) & ~0x3f) == 0 && ((1L << (_la - 61)) & ((1L << (TSTP - 61)) | (1L << (TSFP - 61)) | (1L << (ATSFP - 61)) | (1L << (CLTT - 61)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 334; Match(NUMBER);
			State = 335; Match(Date);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartEndContext : ParserRuleContext {
		public ITerminalNode Date() { return GetToken(DHCPDConfigParser.Date, 0); }
		public ITerminalNode STARTS() { return GetToken(DHCPDConfigParser.STARTS, 0); }
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public ITerminalNode ENDS() { return GetToken(DHCPDConfigParser.ENDS, 0); }
		public StartEndContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_startEnd; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterStartEnd(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitStartEnd(this);
		}
	}

	[RuleVersion(0)]
	public StartEndContext startEnd() {
		StartEndContext _localctx = new StartEndContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_startEnd);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 337;
			_la = _input.La(1);
			if ( !(_la==STARTS || _la==ENDS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 338; Match(NUMBER);
			State = 339; Match(Date);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaseParameterContext : ParserRuleContext {
		public ITerminalNode NEXT() { return GetToken(DHCPDConfigParser.NEXT, 0); }
		public StartEndContext startEnd() {
			return GetRuleContext<StartEndContext>(0);
		}
		public TimestampContext timestamp() {
			return GetRuleContext<TimestampContext>(0);
		}
		public StateContext state() {
			return GetRuleContext<StateContext>(0);
		}
		public ITerminalNode DYNAMIC_BOOTP() { return GetToken(DHCPDConfigParser.DYNAMIC_BOOTP, 0); }
		public ITerminalNode CLASS() { return GetToken(DHCPDConfigParser.CLASS, 0); }
		public ITerminalNode STATE() { return GetToken(DHCPDConfigParser.STATE, 0); }
		public ITerminalNode SEMI() { return GetToken(DHCPDConfigParser.SEMI, 0); }
		public HardwareParameterContext hardwareParameter() {
			return GetRuleContext<HardwareParameterContext>(0);
		}
		public ITerminalNode CLIENT_HOSTNAME() { return GetToken(DHCPDConfigParser.CLIENT_HOSTNAME, 0); }
		public StringParameterContext stringParameter() {
			return GetRuleContext<StringParameterContext>(0);
		}
		public ITerminalNode BINDING() { return GetToken(DHCPDConfigParser.BINDING, 0); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public ITerminalNode UIDSTRING() { return GetToken(DHCPDConfigParser.UIDSTRING, 0); }
		public LeaseParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_leaseParameter; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterLeaseParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitLeaseParameter(this);
		}
	}

	[RuleVersion(0)]
	public LeaseParameterContext leaseParameter() {
		LeaseParameterContext _localctx = new LeaseParameterContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_leaseParameter);
		try {
			State = 371;
			switch (_input.La(1)) {
			case STARTS:
			case ENDS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 341; startEnd();
				State = 342; Match(SEMI);
				}
				break;
			case TSTP:
			case TSFP:
			case ATSFP:
			case CLTT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 344; timestamp();
				State = 345; Match(SEMI);
				}
				break;
			case HARDWARE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 347; hardwareParameter();
				State = 348; Match(SEMI);
				}
				break;
			case UIDSTRING:
				EnterOuterAlt(_localctx, 4);
				{
				State = 350; Match(UIDSTRING);
				}
				break;
			case CLIENT_HOSTNAME:
				EnterOuterAlt(_localctx, 5);
				{
				State = 351; Match(CLIENT_HOSTNAME);
				State = 352; stringParameter();
				State = 353; Match(SEMI);
				}
				break;
			case BINDING:
				EnterOuterAlt(_localctx, 6);
				{
				State = 355; Match(BINDING);
				State = 356; Match(STATE);
				State = 357; state();
				State = 358; Match(SEMI);
				}
				break;
			case NEXT:
				EnterOuterAlt(_localctx, 7);
				{
				State = 360; Match(NEXT);
				State = 361; Match(BINDING);
				State = 362; Match(STATE);
				State = 363; state();
				State = 364; Match(SEMI);
				}
				break;
			case CLASS:
				EnterOuterAlt(_localctx, 8);
				{
				State = 366; Match(CLASS);
				State = 367; Match(STRING);
				State = 368; Match(SEMI);
				}
				break;
			case DYNAMIC_BOOTP:
				EnterOuterAlt(_localctx, 9);
				{
				State = 369; Match(DYNAMIC_BOOTP);
				State = 370; Match(SEMI);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PoolDeclarationContext : ParserRuleContext {
		public ITerminalNode POOL() { return GetToken(DHCPDConfigParser.POOL, 0); }
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public PoolDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_poolDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterPoolDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitPoolDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public PoolDeclarationContext poolDeclaration() {
		PoolDeclarationContext _localctx = new PoolDeclarationContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_poolDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 373; Match(POOL);
			State = 374; Match(LBRACE);
			State = 375; statements();
			State = 376; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeLowContext : ParserRuleContext {
		public Ip4AddressContext ip4Address() {
			return GetRuleContext<Ip4AddressContext>(0);
		}
		public RangeLowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_rangeLow; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterRangeLow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitRangeLow(this);
		}
	}

	[RuleVersion(0)]
	public RangeLowContext rangeLow() {
		RangeLowContext _localctx = new RangeLowContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_rangeLow);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 378; ip4Address();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeHighContext : ParserRuleContext {
		public Ip4AddressContext ip4Address() {
			return GetRuleContext<Ip4AddressContext>(0);
		}
		public RangeHighContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_rangeHigh; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterRangeHigh(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitRangeHigh(this);
		}
	}

	[RuleVersion(0)]
	public RangeHighContext rangeHigh() {
		RangeHighContext _localctx = new RangeHighContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_rangeHigh);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 380; ip4Address();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddressRangeDeclarationContext : ParserRuleContext {
		public ITerminalNode RANGE() { return GetToken(DHCPDConfigParser.RANGE, 0); }
		public StringParameterContext stringParameter(int i) {
			return GetRuleContext<StringParameterContext>(i);
		}
		public ITerminalNode SEMI() { return GetToken(DHCPDConfigParser.SEMI, 0); }
		public IReadOnlyList<StringParameterContext> stringParameter() {
			return GetRuleContexts<StringParameterContext>();
		}
		public RangeHighContext rangeHigh() {
			return GetRuleContext<RangeHighContext>(0);
		}
		public RangeLowContext rangeLow() {
			return GetRuleContext<RangeLowContext>(0);
		}
		public ITerminalNode DYNAMIC_BOOTP() { return GetToken(DHCPDConfigParser.DYNAMIC_BOOTP, 0); }
		public AddressRangeDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_addressRangeDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterAddressRangeDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitAddressRangeDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public AddressRangeDeclarationContext addressRangeDeclaration() {
		AddressRangeDeclarationContext _localctx = new AddressRangeDeclarationContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_addressRangeDeclaration);
		try {
			State = 392;
			switch (_input.La(1)) {
			case RANGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 382; Match(RANGE);
				State = 383; rangeLow();
				State = 384; rangeHigh();
				State = 385; Match(SEMI);
				}
				break;
			case DYNAMIC_BOOTP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 387; Match(DYNAMIC_BOOTP);
				State = 388; stringParameter();
				State = 389; stringParameter();
				State = 390; Match(SEMI);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeLow6Context : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public RangeLow6Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_rangeLow6; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterRangeLow6(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitRangeLow6(this);
		}
	}

	[RuleVersion(0)]
	public RangeLow6Context rangeLow6() {
		RangeLow6Context _localctx = new RangeLow6Context(_ctx, State);
		EnterRule(_localctx, 70, RULE_rangeLow6);
		try {
			State = 398;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 394; Match(QUOTE);
				State = 395; Match(STRING);
				State = 396; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 397; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeHigh6Context : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public RangeHigh6Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_rangeHigh6; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterRangeHigh6(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitRangeHigh6(this);
		}
	}

	[RuleVersion(0)]
	public RangeHigh6Context rangeHigh6() {
		RangeHigh6Context _localctx = new RangeHigh6Context(_ctx, State);
		EnterRule(_localctx, 72, RULE_rangeHigh6);
		try {
			State = 404;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 400; Match(QUOTE);
				State = 401; Match(STRING);
				State = 402; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 403; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AddressRange6DeclarationContext : ParserRuleContext {
		public RangeHigh6Context rangeHigh6() {
			return GetRuleContext<RangeHigh6Context>(0);
		}
		public ITerminalNode TEMPORARY() { return GetToken(DHCPDConfigParser.TEMPORARY, 0); }
		public ITerminalNode SEMI() { return GetToken(DHCPDConfigParser.SEMI, 0); }
		public RangeLow6Context rangeLow6() {
			return GetRuleContext<RangeLow6Context>(0);
		}
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public StringParameterContext stringParameter() {
			return GetRuleContext<StringParameterContext>(0);
		}
		public ITerminalNode LBRACKET() { return GetToken(DHCPDConfigParser.LBRACKET, 0); }
		public ITerminalNode RBRACKET() { return GetToken(DHCPDConfigParser.RBRACKET, 0); }
		public ITerminalNode SLASH() { return GetToken(DHCPDConfigParser.SLASH, 0); }
		public AddressRange6DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_addressRange6Declaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterAddressRange6Declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitAddressRange6Declaration(this);
		}
	}

	[RuleVersion(0)]
	public AddressRange6DeclarationContext addressRange6Declaration() {
		AddressRange6DeclarationContext _localctx = new AddressRange6DeclarationContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_addressRange6Declaration);
		try {
			State = 423;
			switch ( Interpreter.AdaptivePredict(_input,20,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 406; rangeLow6();
				State = 407; rangeHigh6();
				State = 408; Match(SEMI);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 410; stringParameter();
				State = 411; Match(SLASH);
				State = 412; Match(NUMBER);
				State = 413; Match(SEMI);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 415; stringParameter();
				State = 416; Match(LBRACKET);
				State = 417; Match(SLASH);
				State = 418; Match(NUMBER);
				State = 419; Match(RBRACKET);
				State = 420; Match(TEMPORARY);
				State = 421; Match(SEMI);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ip6AddressContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public Ip6AddressContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_ip6Address; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterIp6Address(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitIp6Address(this);
		}
	}

	[RuleVersion(0)]
	public Ip6AddressContext ip6Address() {
		Ip6AddressContext _localctx = new Ip6AddressContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_ip6Address);
		try {
			State = 429;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 425; Match(QUOTE);
				State = 426; Match(STRING);
				State = 427; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 428; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedPrefix6Context : ParserRuleContext {
		public ITerminalNode SEMI() { return GetToken(DHCPDConfigParser.SEMI, 0); }
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public Ip6AddressContext ip6Address() {
			return GetRuleContext<Ip6AddressContext>(0);
		}
		public ITerminalNode SLASH() { return GetToken(DHCPDConfigParser.SLASH, 0); }
		public FixedPrefix6Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_fixedPrefix6; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterFixedPrefix6(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitFixedPrefix6(this);
		}
	}

	[RuleVersion(0)]
	public FixedPrefix6Context fixedPrefix6() {
		FixedPrefix6Context _localctx = new FixedPrefix6Context(_ctx, State);
		EnterRule(_localctx, 78, RULE_fixedPrefix6);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 431; ip6Address();
			State = 432; Match(SLASH);
			State = 433; Match(NUMBER);
			State = 434; Match(SEMI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FailoverDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public ITerminalNode PEER() { return GetToken(DHCPDConfigParser.PEER, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode FAILOVER() { return GetToken(DHCPDConfigParser.FAILOVER, 0); }
		public ITerminalNode SEMI() { return GetToken(DHCPDConfigParser.SEMI, 0); }
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public HostnameOrIpAddressContext hostnameOrIpAddress() {
			return GetRuleContext<HostnameOrIpAddressContext>(0);
		}
		public FailoverDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_failoverDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterFailoverDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitFailoverDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public FailoverDeclarationContext failoverDeclaration() {
		FailoverDeclarationContext _localctx = new FailoverDeclarationContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_failoverDeclaration);
		try {
			State = 448;
			switch ( Interpreter.AdaptivePredict(_input,22,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 436; Match(FAILOVER);
				State = 437; Match(PEER);
				State = 438; hostnameOrIpAddress();
				State = 439; Match(LBRACE);
				State = 440; statements();
				State = 441; Match(RBRACE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 443; Match(FAILOVER);
				State = 444; Match(PEER);
				State = 445; hostnameOrIpAddress();
				State = 446; Match(SEMI);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FailoverStateDeclarationContext : ParserRuleContext {
		public ITerminalNode LBRACE() { return GetToken(DHCPDConfigParser.LBRACE, 0); }
		public ITerminalNode PEER() { return GetToken(DHCPDConfigParser.PEER, 0); }
		public ITerminalNode STATE() { return GetToken(DHCPDConfigParser.STATE, 0); }
		public ITerminalNode FAILOVER() { return GetToken(DHCPDConfigParser.FAILOVER, 0); }
		public FailoverStateStatementContext failoverStateStatement(int i) {
			return GetRuleContext<FailoverStateStatementContext>(i);
		}
		public IReadOnlyList<FailoverStateStatementContext> failoverStateStatement() {
			return GetRuleContexts<FailoverStateStatementContext>();
		}
		public ITerminalNode RBRACE() { return GetToken(DHCPDConfigParser.RBRACE, 0); }
		public HostnameOrIpAddressContext hostnameOrIpAddress() {
			return GetRuleContext<HostnameOrIpAddressContext>(0);
		}
		public FailoverStateDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_failoverStateDeclaration; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterFailoverStateDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitFailoverStateDeclaration(this);
		}
	}

	[RuleVersion(0)]
	public FailoverStateDeclarationContext failoverStateDeclaration() {
		FailoverStateDeclarationContext _localctx = new FailoverStateDeclarationContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_failoverStateDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 450; Match(FAILOVER);
			State = 451; Match(PEER);
			State = 452; hostnameOrIpAddress();
			State = 453; Match(STATE);
			State = 454; Match(LBRACE);
			State = 458;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==MY || _la==PARTNER) {
				{
				{
				State = 455; failoverStateStatement();
				}
				}
				State = 460;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 461; Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StateContext : ParserRuleContext {
		public ITerminalNode QUOTE(int i) {
			return GetToken(DHCPDConfigParser.QUOTE, i);
		}
		public IReadOnlyList<ITerminalNode> QUOTE() { return GetTokens(DHCPDConfigParser.QUOTE); }
		public ITerminalNode STRING() { return GetToken(DHCPDConfigParser.STRING, 0); }
		public StateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_state; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterState(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitState(this);
		}
	}

	[RuleVersion(0)]
	public StateContext state() {
		StateContext _localctx = new StateContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_state);
		try {
			State = 467;
			switch (_input.La(1)) {
			case QUOTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 463; Match(QUOTE);
				State = 464; Match(STRING);
				State = 465; Match(QUOTE);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 466; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateContext : ParserRuleContext {
		public ITerminalNode STRING(int i) {
			return GetToken(DHCPDConfigParser.STRING, i);
		}
		public ITerminalNode Date() { return GetToken(DHCPDConfigParser.Date, 0); }
		public IReadOnlyList<ITerminalNode> STRING() { return GetTokens(DHCPDConfigParser.STRING); }
		public DateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_date; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterDate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitDate(this);
		}
	}

	[RuleVersion(0)]
	public DateContext date() {
		DateContext _localctx = new DateContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_date);
		try {
			State = 472;
			switch (_input.La(1)) {
			case Date:
				EnterOuterAlt(_localctx, 1);
				{
				State = 469; Match(Date);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 470; Match(STRING);
				State = 471; Match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FailoverStateStatementContext : ParserRuleContext {
		public ITerminalNode STATE() { return GetToken(DHCPDConfigParser.STATE, 0); }
		public ITerminalNode PARTNER() { return GetToken(DHCPDConfigParser.PARTNER, 0); }
		public ITerminalNode SEMI() { return GetToken(DHCPDConfigParser.SEMI, 0); }
		public ITerminalNode MY() { return GetToken(DHCPDConfigParser.MY, 0); }
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public DateContext date() {
			return GetRuleContext<DateContext>(0);
		}
		public ITerminalNode AT() { return GetToken(DHCPDConfigParser.AT, 0); }
		public StateContext state() {
			return GetRuleContext<StateContext>(0);
		}
		public FailoverStateStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_failoverStateStatement; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterFailoverStateStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitFailoverStateStatement(this);
		}
	}

	[RuleVersion(0)]
	public FailoverStateStatementContext failoverStateStatement() {
		FailoverStateStatementContext _localctx = new FailoverStateStatementContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_failoverStateStatement);
		try {
			State = 490;
			switch (_input.La(1)) {
			case MY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 474; Match(MY);
				State = 475; Match(STATE);
				State = 476; state();
				State = 477; Match(AT);
				State = 478; Match(NUMBER);
				State = 479; date();
				State = 480; Match(SEMI);
				}
				break;
			case PARTNER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 482; Match(PARTNER);
				State = 483; Match(STATE);
				State = 484; state();
				State = 485; Match(AT);
				State = 486; Match(NUMBER);
				State = 487; date();
				State = 488; Match(SEMI);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PeerStatementContext : ParserRuleContext {
		public ITerminalNode PEER() { return GetToken(DHCPDConfigParser.PEER, 0); }
		public ITerminalNode PORT() { return GetToken(DHCPDConfigParser.PORT, 0); }
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public HostnameOrIpAddressContext hostnameOrIpAddress() {
			return GetRuleContext<HostnameOrIpAddressContext>(0);
		}
		public ITerminalNode ADDRESS() { return GetToken(DHCPDConfigParser.ADDRESS, 0); }
		public PeerStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_peerStatement; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterPeerStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitPeerStatement(this);
		}
	}

	[RuleVersion(0)]
	public PeerStatementContext peerStatement() {
		PeerStatementContext _localctx = new PeerStatementContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_peerStatement);
		try {
			State = 498;
			switch ( Interpreter.AdaptivePredict(_input,27,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 492; Match(PEER);
				State = 493; Match(ADDRESS);
				State = 494; hostnameOrIpAddress();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 495; Match(PEER);
				State = 496; Match(PORT);
				State = 497; Match(NUMBER);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeaseTimeContext : ParserRuleContext {
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public LeaseTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_leaseTime; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterLeaseTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitLeaseTime(this);
		}
	}

	[RuleVersion(0)]
	public LeaseTimeContext leaseTime() {
		LeaseTimeContext _localctx = new LeaseTimeContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_leaseTime);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 500; Match(NUMBER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IpAddressWithSubnetContext : ParserRuleContext {
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public StringParameterContext stringParameter() {
			return GetRuleContext<StringParameterContext>(0);
		}
		public ITerminalNode SLASH() { return GetToken(DHCPDConfigParser.SLASH, 0); }
		public IpAddressWithSubnetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_ipAddressWithSubnet; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterIpAddressWithSubnet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitIpAddressWithSubnet(this);
		}
	}

	[RuleVersion(0)]
	public IpAddressWithSubnetContext ipAddressWithSubnet() {
		IpAddressWithSubnetContext _localctx = new IpAddressWithSubnetContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_ipAddressWithSubnet);
		try {
			State = 507;
			switch ( Interpreter.AdaptivePredict(_input,28,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 502; stringParameter();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 503; stringParameter();
				State = 504; Match(SLASH);
				State = 505; Match(NUMBER);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ip6PrefixContext : ParserRuleContext {
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public StringParameterContext stringParameter() {
			return GetRuleContext<StringParameterContext>(0);
		}
		public ITerminalNode SLASH() { return GetToken(DHCPDConfigParser.SLASH, 0); }
		public Ip6PrefixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_ip6Prefix; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterIp6Prefix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitIp6Prefix(this);
		}
	}

	[RuleVersion(0)]
	public Ip6PrefixContext ip6Prefix() {
		Ip6PrefixContext _localctx = new Ip6PrefixContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_ip6Prefix);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 509; stringParameter();
			State = 510; Match(SLASH);
			State = 511; Match(NUMBER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HardwareParameterContext : ParserRuleContext {
		public ITerminalNode HARDWARE() { return GetToken(DHCPDConfigParser.HARDWARE, 0); }
		public ITerminalNode ColonSeparatedList() { return GetToken(DHCPDConfigParser.ColonSeparatedList, 0); }
		public ITerminalNode HARDWARE_TYPES() { return GetToken(DHCPDConfigParser.HARDWARE_TYPES, 0); }
		public HardwareParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_hardwareParameter; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterHardwareParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitHardwareParameter(this);
		}
	}

	[RuleVersion(0)]
	public HardwareParameterContext hardwareParameter() {
		HardwareParameterContext _localctx = new HardwareParameterContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_hardwareParameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 513; Match(HARDWARE);
			State = 514; Match(HARDWARE_TYPES);
			State = 515; Match(ColonSeparatedList);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionParamContext : ParserRuleContext {
		public StringParameterContext stringParameter(int i) {
			return GetRuleContext<StringParameterContext>(i);
		}
		public IReadOnlyList<StringParameterContext> stringParameter() {
			return GetRuleContexts<StringParameterContext>();
		}
		public OptionParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_optionParam; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterOptionParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitOptionParam(this);
		}
	}

	[RuleVersion(0)]
	public OptionParamContext optionParam() {
		OptionParamContext _localctx = new OptionParamContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_optionParam);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 520;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,29,_ctx);
			while ( _alt!=2 && _alt!=-1 ) {
				if ( _alt==1 ) {
					{
					{
					State = 517; stringParameter();
					}
					} 
				}
				State = 522;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,29,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionStatementContext : ParserRuleContext {
		public ITerminalNode PORT() { return GetToken(DHCPDConfigParser.PORT, 0); }
		public OptionParamContext optionParam() {
			return GetRuleContext<OptionParamContext>(0);
		}
		public ITerminalNode NUMBER() { return GetToken(DHCPDConfigParser.NUMBER, 0); }
		public ITerminalNode ADDRESS() { return GetToken(DHCPDConfigParser.ADDRESS, 0); }
		public HostnameOrIpAddressContext hostnameOrIpAddress() {
			return GetRuleContext<HostnameOrIpAddressContext>(0);
		}
		public ITerminalNode ColonSeparatedList() { return GetToken(DHCPDConfigParser.ColonSeparatedList, 0); }
		public ITerminalNode Boolean() { return GetToken(DHCPDConfigParser.Boolean, 0); }
		public ITerminalNode Ip4Address() { return GetToken(DHCPDConfigParser.Ip4Address, 0); }
		public OptionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_optionStatement; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterOptionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitOptionStatement(this);
		}
	}

	[RuleVersion(0)]
	public OptionStatementContext optionStatement() {
		OptionStatementContext _localctx = new OptionStatementContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_optionStatement);
		try {
			State = 540;
			switch ( Interpreter.AdaptivePredict(_input,30,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 523; optionParam();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 524; optionParam();
				State = 525; Match(NUMBER);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 527; optionParam();
				State = 528; Match(Boolean);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 530; optionParam();
				State = 531; hostnameOrIpAddress();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 533; optionParam();
				State = 534; Match(ColonSeparatedList);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 536; Match(PORT);
				State = 537; Match(NUMBER);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 538; Match(ADDRESS);
				State = 539; Match(Ip4Address);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionOptionStatementContext : ParserRuleContext {
		public OptionStatementContext optionStatement() {
			return GetRuleContext<OptionStatementContext>(0);
		}
		public ITerminalNode OPTION() { return GetToken(DHCPDConfigParser.OPTION, 0); }
		public OptionOptionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_optionOptionStatement; }
		public override void EnterRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.EnterOptionOptionStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDHCPDConfigListener typedListener = listener as IDHCPDConfigListener;
			if (typedListener != null) typedListener.ExitOptionOptionStatement(this);
		}
	}

	[RuleVersion(0)]
	public OptionOptionStatementContext optionOptionStatement() {
		OptionOptionStatementContext _localctx = new OptionOptionStatementContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_optionOptionStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 542; Match(OPTION);
			State = 543; optionStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xACF5\xEE8C\x4F5D\x8B0D\x4A45\x78BD\x1B2F\x3378\x3S\x224\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x3\x2\a\x2"+
		"n\n\x2\f\x2\xE\x2q\v\x2\x3\x3\x3\x3\x3\x3\x3\x3\x5\x3w\n\x3\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3"+
		"\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3"+
		"\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3"+
		"\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4\xC6\n\x4\x3\x5\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5\xD5"+
		"\n\x5\x3\x6\x3\x6\x5\x6\xD9\n\x6\x3\a\a\a\xDC\n\a\f\a\xE\a\xDF\v\a\x3"+
		"\b\x3\b\x3\b\x3\b\x3\b\x5\b\xE6\n\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\n"+
		"\x3\n\x3\n\x3\n\x5\n\xF2\n\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\f\x3\f\x3"+
		"\f\x3\f\x5\f\xFE\n\f\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3\xF\x3"+
		"\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x11\x3"+
		"\x11\x3\x11\x3\x11\x5\x11\x116\n\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12"+
		"\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x14\x3\x14\x3\x15\x3\x15"+
		"\x3\x15\x3\x16\x3\x16\x3\x16\x3\x16\x6\x16\x12C\n\x16\r\x16\xE\x16\x12D"+
		"\x3\x17\x3\x17\x3\x17\x3\x17\x5\x17\x134\n\x17\x3\x18\x3\x18\x3\x19\x3"+
		"\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x1A\a\x1A\x13F\n\x1A\f\x1A\xE\x1A"+
		"\x142\v\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x148\n\x1B\x3\x1C\x3\x1C"+
		"\x3\x1D\x3\x1D\x5\x1D\x14E\n\x1D\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1F\x3"+
		"\x1F\x3\x1F\x3\x1F\x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3"+
		" \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 "+
		"\x5 \x176\n \x3!\x3!\x3!\x3!\x3!\x3\"\x3\"\x3#\x3#\x3$\x3$\x3$\x3$\x3"+
		"$\x3$\x3$\x3$\x3$\x3$\x5$\x18B\n$\x3%\x3%\x3%\x3%\x5%\x191\n%\x3&\x3&"+
		"\x3&\x3&\x5&\x197\n&\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'"+
		"\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x5\'\x1AA\n\'\x3(\x3(\x3(\x3(\x5("+
		"\x1B0\n(\x3)\x3)\x3)\x3)\x3)\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3"+
		"*\x3*\x5*\x1C3\n*\x3+\x3+\x3+\x3+\x3+\x3+\a+\x1CB\n+\f+\xE+\x1CE\v+\x3"+
		"+\x3+\x3,\x3,\x3,\x3,\x5,\x1D6\n,\x3-\x3-\x3-\x5-\x1DB\n-\x3.\x3.\x3."+
		"\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x5.\x1ED\n.\x3/\x3"+
		"/\x3/\x3/\x3/\x3/\x5/\x1F5\n/\x3\x30\x3\x30\x3\x31\x3\x31\x3\x31\x3\x31"+
		"\x3\x31\x5\x31\x1FE\n\x31\x3\x32\x3\x32\x3\x32\x3\x32\x3\x33\x3\x33\x3"+
		"\x33\x3\x33\x3\x34\a\x34\x209\n\x34\f\x34\xE\x34\x20C\v\x34\x3\x35\x3"+
		"\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3"+
		"\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x5\x35\x21F\n\x35\x3\x36\x3\x36"+
		"\x3\x36\x3\x36\x2\x37\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E"+
		" \"$&(*,.\x30\x32\x34\x36\x38:<>@\x42\x44\x46HJLNPRTVXZ\\^`\x62\x64\x66"+
		"hj\x2\x4\x4\x2?\x41\x44\x44\x3\x2\x16\x17\x23B\x2o\x3\x2\x2\x2\x4v\x3"+
		"\x2\x2\x2\x6\xC5\x3\x2\x2\x2\b\xD4\x3\x2\x2\x2\n\xD8\x3\x2\x2\x2\f\xDD"+
		"\x3\x2\x2\x2\xE\xE5\x3\x2\x2\x2\x10\xE7\x3\x2\x2\x2\x12\xF1\x3\x2\x2\x2"+
		"\x14\xF3\x3\x2\x2\x2\x16\xFD\x3\x2\x2\x2\x18\xFF\x3\x2\x2\x2\x1A\x105"+
		"\x3\x2\x2\x2\x1C\x107\x3\x2\x2\x2\x1E\x109\x3\x2\x2\x2 \x115\x3\x2\x2"+
		"\x2\"\x117\x3\x2\x2\x2$\x11D\x3\x2\x2\x2&\x122\x3\x2\x2\x2(\x124\x3\x2"+
		"\x2\x2*\x12B\x3\x2\x2\x2,\x133\x3\x2\x2\x2.\x135\x3\x2\x2\x2\x30\x137"+
		"\x3\x2\x2\x2\x32\x140\x3\x2\x2\x2\x34\x147\x3\x2\x2\x2\x36\x149\x3\x2"+
		"\x2\x2\x38\x14D\x3\x2\x2\x2:\x14F\x3\x2\x2\x2<\x153\x3\x2\x2\x2>\x175"+
		"\x3\x2\x2\x2@\x177\x3\x2\x2\x2\x42\x17C\x3\x2\x2\x2\x44\x17E\x3\x2\x2"+
		"\x2\x46\x18A\x3\x2\x2\x2H\x190\x3\x2\x2\x2J\x196\x3\x2\x2\x2L\x1A9\x3"+
		"\x2\x2\x2N\x1AF\x3\x2\x2\x2P\x1B1\x3\x2\x2\x2R\x1C2\x3\x2\x2\x2T\x1C4"+
		"\x3\x2\x2\x2V\x1D5\x3\x2\x2\x2X\x1DA\x3\x2\x2\x2Z\x1EC\x3\x2\x2\x2\\\x1F4"+
		"\x3\x2\x2\x2^\x1F6\x3\x2\x2\x2`\x1FD\x3\x2\x2\x2\x62\x1FF\x3\x2\x2\x2"+
		"\x64\x203\x3\x2\x2\x2\x66\x20A\x3\x2\x2\x2h\x21E\x3\x2\x2\x2j\x220\x3"+
		"\x2\x2\x2ln\x5\n\x6\x2ml\x3\x2\x2\x2nq\x3\x2\x2\x2om\x3\x2\x2\x2op\x3"+
		"\x2\x2\x2p\x3\x3\x2\x2\x2qo\x3\x2\x2\x2rs\aH\x2\x2st\aQ\x2\x2tw\aH\x2"+
		"\x2uw\aQ\x2\x2vr\x3\x2\x2\x2vu\x3\x2\x2\x2w\x5\x3\x2\x2\x2xy\a)\x2\x2"+
		"yz\x5^\x30\x2z{\a\x6\x2\x2{\xC6\x3\x2\x2\x2|}\a*\x2\x2}~\x5^\x30\x2~\x7F"+
		"\a\x6\x2\x2\x7F\xC6\x3\x2\x2\x2\x80\x81\a+\x2\x2\x81\x82\aJ\x2\x2\x82"+
		"\xC6\a\x6\x2\x2\x83\x84\a,\x2\x2\x84\x85\x5^\x30\x2\x85\x86\a\x6\x2\x2"+
		"\x86\xC6\x3\x2\x2\x2\x87\x88\a-\x2\x2\x88\x89\x5\x4\x3\x2\x89\x8A\a\x6"+
		"\x2\x2\x8A\xC6\x3\x2\x2\x2\x8B\x8C\a.\x2\x2\x8C\x8D\aG\x2\x2\x8D\xC6\a"+
		"\x6\x2\x2\x8E\x8F\a/\x2\x2\x8F\x90\aG\x2\x2\x90\xC6\a\x6\x2\x2\x91\x92"+
		"\a\x30\x2\x2\x92\x93\aG\x2\x2\x93\xC6\a\x6\x2\x2\x94\x95\a\x31\x2\x2\x95"+
		"\x96\x5\x4\x3\x2\x96\x97\a\x6\x2\x2\x97\xC6\x3\x2\x2\x2\x98\x99\a\x32"+
		"\x2\x2\x99\x9A\x5\x4\x3\x2\x9A\x9B\a\x6\x2\x2\x9B\xC6\x3\x2\x2\x2\x9C"+
		"\x9D\a\x33\x2\x2\x9D\x9E\x5\x4\x3\x2\x9E\x9F\a\x6\x2\x2\x9F\xC6\x3\x2"+
		"\x2\x2\xA0\xA1\x5\x64\x33\x2\xA1\xA2\a\x6\x2\x2\xA2\xC6\x3\x2\x2\x2\xA3"+
		"\xA4\x5(\x15\x2\xA4\xA5\a\x6\x2\x2\xA5\xC6\x3\x2\x2\x2\xA6\xA7\a\x34\x2"+
		"\x2\xA7\xA8\a\"\x2\x2\xA8\xC6\a\x6\x2\x2\xA9\xAA\a\x35\x2\x2\xAA\xAB\a"+
		"\"\x2\x2\xAB\xC6\a\x6\x2\x2\xAC\xAD\a\x36\x2\x2\xAD\xAE\aG\x2\x2\xAE\xC6"+
		"\a\x6\x2\x2\xAF\xB0\a\x37\x2\x2\xB0\xC6\a\x6\x2\x2\xB1\xB2\a\x38\x2\x2"+
		"\xB2\xC6\a\x6\x2\x2\xB3\xB4\a\x39\x2\x2\xB4\xC6\a\x6\x2\x2\xB5\xB6\a:"+
		"\x2\x2\xB6\xC6\a\x6\x2\x2\xB7\xB8\x5> \x2\xB8\xB9\a\x6\x2\x2\xB9\xC6\x3"+
		"\x2\x2\x2\xBA\xBB\x5h\x35\x2\xBB\xBC\a\x6\x2\x2\xBC\xC6\x3\x2\x2\x2\xBD"+
		"\xBE\x5\\/\x2\xBE\xBF\a\x6\x2\x2\xBF\xC6\x3\x2\x2\x2\xC0\xC6\aP\x2\x2"+
		"\xC1\xC2\a;\x2\x2\xC2\xC3\x5h\x35\x2\xC3\xC4\a\x6\x2\x2\xC4\xC6\x3\x2"+
		"\x2\x2\xC5x\x3\x2\x2\x2\xC5|\x3\x2\x2\x2\xC5\x80\x3\x2\x2\x2\xC5\x83\x3"+
		"\x2\x2\x2\xC5\x87\x3\x2\x2\x2\xC5\x8B\x3\x2\x2\x2\xC5\x8E\x3\x2\x2\x2"+
		"\xC5\x91\x3\x2\x2\x2\xC5\x94\x3\x2\x2\x2\xC5\x98\x3\x2\x2\x2\xC5\x9C\x3"+
		"\x2\x2\x2\xC5\xA0\x3\x2\x2\x2\xC5\xA3\x3\x2\x2\x2\xC5\xA6\x3\x2\x2\x2"+
		"\xC5\xA9\x3\x2\x2\x2\xC5\xAC\x3\x2\x2\x2\xC5\xAF\x3\x2\x2\x2\xC5\xB1\x3"+
		"\x2\x2\x2\xC5\xB3\x3\x2\x2\x2\xC5\xB5\x3\x2\x2\x2\xC5\xB7\x3\x2\x2\x2"+
		"\xC5\xBA\x3\x2\x2\x2\xC5\xBD\x3\x2\x2\x2\xC5\xC0\x3\x2\x2\x2\xC5\xC1\x3"+
		"\x2\x2\x2\xC6\a\x3\x2\x2\x2\xC7\xD5\x5\x10\t\x2\xC8\xD5\x5$\x13\x2\xC9"+
		"\xD5\x5\x18\r\x2\xCA\xD5\x5\x1E\x10\x2\xCB\xCC\a<\x2\x2\xCC\xD5\x5\x14"+
		"\v\x2\xCD\xCE\a=\x2\x2\xCE\xD5\x5\x14\v\x2\xCF\xD5\x5R*\x2\xD0\xD5\x5"+
		"T+\x2\xD1\xD5\x5\x46$\x2\xD2\xD5\x5\x30\x19\x2\xD3\xD5\x5@!\x2\xD4\xC7"+
		"\x3\x2\x2\x2\xD4\xC8\x3\x2\x2\x2\xD4\xC9\x3\x2\x2\x2\xD4\xCA\x3\x2\x2"+
		"\x2\xD4\xCB\x3\x2\x2\x2\xD4\xCD\x3\x2\x2\x2\xD4\xCF\x3\x2\x2\x2\xD4\xD0"+
		"\x3\x2\x2\x2\xD4\xD1\x3\x2\x2\x2\xD4\xD2\x3\x2\x2\x2\xD4\xD3\x3\x2\x2"+
		"\x2\xD5\t\x3\x2\x2\x2\xD6\xD9\x5\x6\x4\x2\xD7\xD9\x5\b\x5\x2\xD8\xD6\x3"+
		"\x2\x2\x2\xD8\xD7\x3\x2\x2\x2\xD9\v\x3\x2\x2\x2\xDA\xDC\x5\n\x6\x2\xDB"+
		"\xDA\x3\x2\x2\x2\xDC\xDF\x3\x2\x2\x2\xDD\xDB\x3\x2\x2\x2\xDD\xDE\x3\x2"+
		"\x2\x2\xDE\r\x3\x2\x2\x2\xDF\xDD\x3\x2\x2\x2\xE0\xE1\aH\x2\x2\xE1\xE2"+
		"\aQ\x2\x2\xE2\xE6\aH\x2\x2\xE3\xE6\aQ\x2\x2\xE4\xE6\aK\x2\x2\xE5\xE0\x3"+
		"\x2\x2\x2\xE5\xE3\x3\x2\x2\x2\xE5\xE4\x3\x2\x2\x2\xE6\xF\x3\x2\x2\x2\xE7"+
		"\xE8\a\xE\x2\x2\xE8\xE9\x5\xE\b\x2\xE9\xEA\a\f\x2\x2\xEA\xEB\x5\f\a\x2"+
		"\xEB\xEC\a\r\x2\x2\xEC\x11\x3\x2\x2\x2\xED\xEE\aH\x2\x2\xEE\xEF\aQ\x2"+
		"\x2\xEF\xF2\aH\x2\x2\xF0\xF2\aQ\x2\x2\xF1\xED\x3\x2\x2\x2\xF1\xF0\x3\x2"+
		"\x2\x2\xF2\x13\x3\x2\x2\x2\xF3\xF4\a\xF\x2\x2\xF4\xF5\x5\x12\n\x2\xF5"+
		"\xF6\a\f\x2\x2\xF6\xF7\x5\f\a\x2\xF7\xF8\a\r\x2\x2\xF8\x15\x3\x2\x2\x2"+
		"\xF9\xFA\aH\x2\x2\xFA\xFB\aQ\x2\x2\xFB\xFE\aH\x2\x2\xFC\xFE\aQ\x2\x2\xFD"+
		"\xF9\x3\x2\x2\x2\xFD\xFC\x3\x2\x2\x2\xFE\x17\x3\x2\x2\x2\xFF\x100\a\x10"+
		"\x2\x2\x100\x101\x5\x16\f\x2\x101\x102\a\f\x2\x2\x102\x103\x5\f\a\x2\x103"+
		"\x104\a\r\x2\x2\x104\x19\x3\x2\x2\x2\x105\x106\x5\x36\x1C\x2\x106\x1B"+
		"\x3\x2\x2\x2\x107\x108\x5\x36\x1C\x2\x108\x1D\x3\x2\x2\x2\x109\x10A\a"+
		"\x11\x2\x2\x10A\x10B\x5\x1A\xE\x2\x10B\x10C\a!\x2\x2\x10C\x10D\x5\x1C"+
		"\xF\x2\x10D\x10E\a\f\x2\x2\x10E\x10F\x5\f\a\x2\x10F\x110\a\r\x2\x2\x110"+
		"\x1F\x3\x2\x2\x2\x111\x112\aH\x2\x2\x112\x113\aQ\x2\x2\x113\x116\aH\x2"+
		"\x2\x114\x116\aQ\x2\x2\x115\x111\x3\x2\x2\x2\x115\x114\x3\x2\x2\x2\x116"+
		"!\x3\x2\x2\x2\x117\x118\a\x12\x2\x2\x118\x119\x5\x4\x3\x2\x119\x11A\a"+
		"\f\x2\x2\x11A\x11B\x5\f\a\x2\x11B\x11C\a\r\x2\x2\x11C#\x3\x2\x2\x2\x11D"+
		"\x11E\a\x13\x2\x2\x11E\x11F\a\f\x2\x2\x11F\x120\x5\f\a\x2\x120\x121\a"+
		"\r\x2\x2\x121%\x3\x2\x2\x2\x122\x123\x5\x36\x1C\x2\x123\'\x3\x2\x2\x2"+
		"\x124\x125\a\x14\x2\x2\x125\x126\x5&\x14\x2\x126)\x3\x2\x2\x2\x127\x128"+
		"\aH\x2\x2\x128\x129\aQ\x2\x2\x129\x12C\aH\x2\x2\x12A\x12C\aQ\x2\x2\x12B"+
		"\x127\x3\x2\x2\x2\x12B\x12A\x3\x2\x2\x2\x12C\x12D\x3\x2\x2\x2\x12D\x12B"+
		"\x3\x2\x2\x2\x12D\x12E\x3\x2\x2\x2\x12E+\x3\x2\x2\x2\x12F\x130\aH\x2\x2"+
		"\x130\x131\aQ\x2\x2\x131\x134\aH\x2\x2\x132\x134\aQ\x2\x2\x133\x12F\x3"+
		"\x2\x2\x2\x133\x132\x3\x2\x2\x2\x134-\x3\x2\x2\x2\x135\x136\x5\x36\x1C"+
		"\x2\x136/\x3\x2\x2\x2\x137\x138\a\x15\x2\x2\x138\x139\x5.\x18\x2\x139"+
		"\x13A\a\f\x2\x2\x13A\x13B\x5\x32\x1A\x2\x13B\x13C\a\r\x2\x2\x13C\x31\x3"+
		"\x2\x2\x2\x13D\x13F\x5> \x2\x13E\x13D\x3\x2\x2\x2\x13F\x142\x3\x2\x2\x2"+
		"\x140\x13E\x3\x2\x2\x2\x140\x141\x3\x2\x2\x2\x141\x33\x3\x2\x2\x2\x142"+
		"\x140\x3\x2\x2\x2\x143\x144\aH\x2\x2\x144\x145\aQ\x2\x2\x145\x148\aH\x2"+
		"\x2\x146\x148\aQ\x2\x2\x147\x143\x3\x2\x2\x2\x147\x146\x3\x2\x2\x2\x148"+
		"\x35\x3\x2\x2\x2\x149\x14A\aL\x2\x2\x14A\x37\x3\x2\x2\x2\x14B\x14E\x5"+
		"\xE\b\x2\x14C\x14E\x5\x36\x1C\x2\x14D\x14B\x3\x2\x2\x2\x14D\x14C\x3\x2"+
		"\x2\x2\x14E\x39\x3\x2\x2\x2\x14F\x150\t\x2\x2\x2\x150\x151\aK\x2\x2\x151"+
		"\x152\aJ\x2\x2\x152;\x3\x2\x2\x2\x153\x154\t\x3\x2\x2\x154\x155\aK\x2"+
		"\x2\x155\x156\aJ\x2\x2\x156=\x3\x2\x2\x2\x157\x158\x5<\x1F\x2\x158\x159"+
		"\a\x6\x2\x2\x159\x176\x3\x2\x2\x2\x15A\x15B\x5:\x1E\x2\x15B\x15C\a\x6"+
		"\x2\x2\x15C\x176\x3\x2\x2\x2\x15D\x15E\x5\x64\x33\x2\x15E\x15F\a\x6\x2"+
		"\x2\x15F\x176\x3\x2\x2\x2\x160\x176\aO\x2\x2\x161\x162\a\x1A\x2\x2\x162"+
		"\x163\x5\x4\x3\x2\x163\x164\a\x6\x2\x2\x164\x176\x3\x2\x2\x2\x165\x166"+
		"\a\x42\x2\x2\x166\x167\a>\x2\x2\x167\x168\x5V,\x2\x168\x169\a\x6\x2\x2"+
		"\x169\x176\x3\x2\x2\x2\x16A\x16B\a\x43\x2\x2\x16B\x16C\a\x42\x2\x2\x16C"+
		"\x16D\a>\x2\x2\x16D\x16E\x5V,\x2\x16E\x16F\a\x6\x2\x2\x16F\x176\x3\x2"+
		"\x2\x2\x170\x171\a\xF\x2\x2\x171\x172\aQ\x2\x2\x172\x176\a\x6\x2\x2\x173"+
		"\x174\a\x1B\x2\x2\x174\x176\a\x6\x2\x2\x175\x157\x3\x2\x2\x2\x175\x15A"+
		"\x3\x2\x2\x2\x175\x15D\x3\x2\x2\x2\x175\x160\x3\x2\x2\x2\x175\x161\x3"+
		"\x2\x2\x2\x175\x165\x3\x2\x2\x2\x175\x16A\x3\x2\x2\x2\x175\x170\x3\x2"+
		"\x2\x2\x175\x173\x3\x2\x2\x2\x176?\x3\x2\x2\x2\x177\x178\a\x1C\x2\x2\x178"+
		"\x179\a\f\x2\x2\x179\x17A\x5\f\a\x2\x17A\x17B\a\r\x2\x2\x17B\x41\x3\x2"+
		"\x2\x2\x17C\x17D\x5\x36\x1C\x2\x17D\x43\x3\x2\x2\x2\x17E\x17F\x5\x36\x1C"+
		"\x2\x17F\x45\x3\x2\x2\x2\x180\x181\a\x1D\x2\x2\x181\x182\x5\x42\"\x2\x182"+
		"\x183\x5\x44#\x2\x183\x184\a\x6\x2\x2\x184\x18B\x3\x2\x2\x2\x185\x186"+
		"\a\x1B\x2\x2\x186\x187\x5\x4\x3\x2\x187\x188\x5\x4\x3\x2\x188\x189\a\x6"+
		"\x2\x2\x189\x18B\x3\x2\x2\x2\x18A\x180\x3\x2\x2\x2\x18A\x185\x3\x2\x2"+
		"\x2\x18BG\x3\x2\x2\x2\x18C\x18D\aH\x2\x2\x18D\x18E\aQ\x2\x2\x18E\x191"+
		"\aH\x2\x2\x18F\x191\aQ\x2\x2\x190\x18C\x3\x2\x2\x2\x190\x18F\x3\x2\x2"+
		"\x2\x191I\x3\x2\x2\x2\x192\x193\aH\x2\x2\x193\x194\aQ\x2\x2\x194\x197"+
		"\aH\x2\x2\x195\x197\aQ\x2\x2\x196\x192\x3\x2\x2\x2\x196\x195\x3\x2\x2"+
		"\x2\x197K\x3\x2\x2\x2\x198\x199\x5H%\x2\x199\x19A\x5J&\x2\x19A\x19B\a"+
		"\x6\x2\x2\x19B\x1AA\x3\x2\x2\x2\x19C\x19D\x5\x4\x3\x2\x19D\x19E\a\x4\x2"+
		"\x2\x19E\x19F\aK\x2\x2\x19F\x1A0\a\x6\x2\x2\x1A0\x1AA\x3\x2\x2\x2\x1A1"+
		"\x1A2\x5\x4\x3\x2\x1A2\x1A3\a\x1F\x2\x2\x1A3\x1A4\a\x4\x2\x2\x1A4\x1A5"+
		"\aK\x2\x2\x1A5\x1A6\a \x2\x2\x1A6\x1A7\a\x1E\x2\x2\x1A7\x1A8\a\x6\x2\x2"+
		"\x1A8\x1AA\x3\x2\x2\x2\x1A9\x198\x3\x2\x2\x2\x1A9\x19C\x3\x2\x2\x2\x1A9"+
		"\x1A1\x3\x2\x2\x2\x1AAM\x3\x2\x2\x2\x1AB\x1AC\aH\x2\x2\x1AC\x1AD\aQ\x2"+
		"\x2\x1AD\x1B0\aH\x2\x2\x1AE\x1B0\aQ\x2\x2\x1AF\x1AB\x3\x2\x2\x2\x1AF\x1AE"+
		"\x3\x2\x2\x2\x1B0O\x3\x2\x2\x2\x1B1\x1B2\x5N(\x2\x1B2\x1B3\a\x4\x2\x2"+
		"\x1B3\x1B4\aK\x2\x2\x1B4\x1B5\a\x6\x2\x2\x1B5Q\x3\x2\x2\x2\x1B6\x1B7\a"+
		"#\x2\x2\x1B7\x1B8\a%\x2\x2\x1B8\x1B9\x5\x38\x1D\x2\x1B9\x1BA\a\f\x2\x2"+
		"\x1BA\x1BB\x5\f\a\x2\x1BB\x1BC\a\r\x2\x2\x1BC\x1C3\x3\x2\x2\x2\x1BD\x1BE"+
		"\a#\x2\x2\x1BE\x1BF\a%\x2\x2\x1BF\x1C0\x5\x38\x1D\x2\x1C0\x1C1\a\x6\x2"+
		"\x2\x1C1\x1C3\x3\x2\x2\x2\x1C2\x1B6\x3\x2\x2\x2\x1C2\x1BD\x3\x2\x2\x2"+
		"\x1C3S\x3\x2\x2\x2\x1C4\x1C5\a#\x2\x2\x1C5\x1C6\a%\x2\x2\x1C6\x1C7\x5"+
		"\x38\x1D\x2\x1C7\x1C8\a>\x2\x2\x1C8\x1CC\a\f\x2\x2\x1C9\x1CB\x5Z.\x2\x1CA"+
		"\x1C9\x3\x2\x2\x2\x1CB\x1CE\x3\x2\x2\x2\x1CC\x1CA\x3\x2\x2\x2\x1CC\x1CD"+
		"\x3\x2\x2\x2\x1CD\x1CF\x3\x2\x2\x2\x1CE\x1CC\x3\x2\x2\x2\x1CF\x1D0\a\r"+
		"\x2\x2\x1D0U\x3\x2\x2\x2\x1D1\x1D2\aH\x2\x2\x1D2\x1D3\aQ\x2\x2\x1D3\x1D6"+
		"\aH\x2\x2\x1D4\x1D6\aQ\x2\x2\x1D5\x1D1\x3\x2\x2\x2\x1D5\x1D4\x3\x2\x2"+
		"\x2\x1D6W\x3\x2\x2\x2\x1D7\x1DB\aJ\x2\x2\x1D8\x1D9\aQ\x2\x2\x1D9\x1DB"+
		"\aQ\x2\x2\x1DA\x1D7\x3\x2\x2\x2\x1DA\x1D8\x3\x2\x2\x2\x1DBY\x3\x2\x2\x2"+
		"\x1DC\x1DD\a\b\x2\x2\x1DD\x1DE\a>\x2\x2\x1DE\x1DF\x5V,\x2\x1DF\x1E0\a"+
		"\n\x2\x2\x1E0\x1E1\aK\x2\x2\x1E1\x1E2\x5X-\x2\x1E2\x1E3\a\x6\x2\x2\x1E3"+
		"\x1ED\x3\x2\x2\x2\x1E4\x1E5\a\t\x2\x2\x1E5\x1E6\a>\x2\x2\x1E6\x1E7\x5"+
		"V,\x2\x1E7\x1E8\a\n\x2\x2\x1E8\x1E9\aK\x2\x2\x1E9\x1EA\x5X-\x2\x1EA\x1EB"+
		"\a\x6\x2\x2\x1EB\x1ED\x3\x2\x2\x2\x1EC\x1DC\x3\x2\x2\x2\x1EC\x1E4\x3\x2"+
		"\x2\x2\x1ED[\x3\x2\x2\x2\x1EE\x1EF\a%\x2\x2\x1EF\x1F0\a&\x2\x2\x1F0\x1F5"+
		"\x5\x38\x1D\x2\x1F1\x1F2\a%\x2\x2\x1F2\x1F3\a\'\x2\x2\x1F3\x1F5\aK\x2"+
		"\x2\x1F4\x1EE\x3\x2\x2\x2\x1F4\x1F1\x3\x2\x2\x2\x1F5]\x3\x2\x2\x2\x1F6"+
		"\x1F7\aK\x2\x2\x1F7_\x3\x2\x2\x2\x1F8\x1FE\x5\x4\x3\x2\x1F9\x1FA\x5\x4"+
		"\x3\x2\x1FA\x1FB\a\x4\x2\x2\x1FB\x1FC\aK\x2\x2\x1FC\x1FE\x3\x2\x2\x2\x1FD"+
		"\x1F8\x3\x2\x2\x2\x1FD\x1F9\x3\x2\x2\x2\x1FE\x61\x3\x2\x2\x2\x1FF\x200"+
		"\x5\x4\x3\x2\x200\x201\a\x4\x2\x2\x201\x202\aK\x2\x2\x202\x63\x3\x2\x2"+
		"\x2\x203\x204\a\x19\x2\x2\x204\x205\a\x46\x2\x2\x205\x206\aI\x2\x2\x206"+
		"\x65\x3\x2\x2\x2\x207\x209\x5\x4\x3\x2\x208\x207\x3\x2\x2\x2\x209\x20C"+
		"\x3\x2\x2\x2\x20A\x208\x3\x2\x2\x2\x20A\x20B\x3\x2\x2\x2\x20Bg\x3\x2\x2"+
		"\x2\x20C\x20A\x3\x2\x2\x2\x20D\x21F\x5\x66\x34\x2\x20E\x20F\x5\x66\x34"+
		"\x2\x20F\x210\aK\x2\x2\x210\x21F\x3\x2\x2\x2\x211\x212\x5\x66\x34\x2\x212"+
		"\x213\aG\x2\x2\x213\x21F\x3\x2\x2\x2\x214\x215\x5\x66\x34\x2\x215\x216"+
		"\x5\x38\x1D\x2\x216\x21F\x3\x2\x2\x2\x217\x218\x5\x66\x34\x2\x218\x219"+
		"\aI\x2\x2\x219\x21F\x3\x2\x2\x2\x21A\x21B\a\'\x2\x2\x21B\x21F\aK\x2\x2"+
		"\x21C\x21D\a&\x2\x2\x21D\x21F\aL\x2\x2\x21E\x20D\x3\x2\x2\x2\x21E\x20E"+
		"\x3\x2\x2\x2\x21E\x211\x3\x2\x2\x2\x21E\x214\x3\x2\x2\x2\x21E\x217\x3"+
		"\x2\x2\x2\x21E\x21A\x3\x2\x2\x2\x21E\x21C\x3\x2\x2\x2\x21Fi\x3\x2\x2\x2"+
		"\x220\x221\a;\x2\x2\x221\x222\x5h\x35\x2\x222k\x3\x2\x2\x2!ov\xC5\xD4"+
		"\xD8\xDD\xE5\xF1\xFD\x115\x12B\x12D\x133\x140\x147\x14D\x175\x18A\x190"+
		"\x196\x1A9\x1AF\x1C2\x1CC\x1D5\x1DA\x1EC\x1F4\x1FD\x20A\x21E";
	public static readonly ATN _ATN =
		ATNSimulator.Deserialize(_serializedATN.ToCharArray());
}
